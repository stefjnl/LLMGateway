# US-002: Domain Layer Implementation

---

## User Story

**As a** developer  
**I want to** implement the Domain layer with entities, value objects, and interfaces  
**So that** I have a pure, testable business logic foundation with zero external dependencies

---

## Acceptance Criteria

### ✅ Criterion 1: Value Objects Implemented
- [ ] `ValueObject` abstract base class with equality comparison logic
- [ ] `ModelName` value object with provider extraction and validation
- [ ] `TokenCount` value object with validation and estimation method
- [ ] `CostAmount` value object with precision handling and arithmetic
- [ ] All value objects are immutable
- [ ] All value objects validate input in constructor/factory methods

### ✅ Criterion 2: Entities Implemented
- [ ] `RequestLog` entity with private constructor and factory method
- [ ] `ModelPricing` entity with cost calculation method
- [ ] Both entities enforce invariants through encapsulation
- [ ] Entities use value objects (not primitives) for domain concepts

### ✅ Criterion 3: Repository Interfaces Defined
- [ ] `IRequestLogRepository` with SaveAsync, GetRecentAsync, GetTotalCostAsync
- [ ] `IModelPricingRepository` with GetByModelAsync, GetAllAsync
- [ ] `IProviderHealthChecker` with IsHealthyAsync, CheckAllProvidersAsync
- [ ] All interfaces use domain types (value objects, entities)
- [ ] All methods use `CancellationToken` for async operations

### ✅ Criterion 4: Domain Exceptions Created
- [ ] `AllProvidersFailedException` with provider list property
- [ ] `TokenLimitExceededException` with requested/max tokens properties
- [ ] `ModelNotFoundException` with requested model property
- [ ] All exceptions inherit from `Exception` with descriptive messages

### ✅ Criterion 5: Domain Constants Defined
- [ ] `ModelDefaults` static class with model names, thresholds, fallback chain
- [ ] Constants match routing strategy from ADR-003

### ✅ Criterion 6: Domain Layer Has Zero Dependencies
- [ ] No NuGet packages referenced in Domain.csproj
- [ ] No using statements for external libraries
- [ ] Only System.* namespaces used
- [ ] Project compiles independently

### ✅ Criterion 7: Unit Tests Pass
- [ ] Value object equality tests (same values = equal)
- [ ] Value object validation tests (invalid input throws)
- [ ] Entity factory method tests (invariants enforced)
- [ ] Token estimation tests (reasonable accuracy)
- [ ] Cost calculation tests (correct arithmetic)
- [ ] All tests pass with 100% coverage on value objects

---

## Prerequisites

**Completed:**
- ✅ US-001: Project structure created
- ✅ Solution compiles
- ✅ Test projects configured with xUnit + FluentAssertions

**Required Knowledge:**
- Value Object pattern (immutability, equality by value)
- Entity pattern (identity, encapsulation)
- Domain-Driven Design basics

---

## Step-by-Step Implementation

### Step 1: Create ValueObject Base Class (5 minutes)

**File**: `src/LLMGateway.Domain/ValueObjects/ValueObject.cs`

```csharp
namespace LLMGateway.Domain.ValueObjects;

public abstract class ValueObject
{
    protected abstract IEnumerable<object> GetEqualityComponents();
    
    public override bool Equals(object? obj)
    {
        if (obj == null || obj.GetType() != GetType())
            return false;
        
        var other = (ValueObject)obj;
        return GetEqualityComponents()
            .SequenceEqual(other.GetEqualityComponents());
    }
    
    public override int GetHashCode()
    {
        return GetEqualityComponents()
            .Select(x => x?.GetHashCode() ?? 0)
            .Aggregate((x, y) => x ^ y);
    }
    
    public static bool operator ==(ValueObject? left, ValueObject? right)
    {
        if (left is null && right is null)
            return true;
        
        if (left is null || right is null)
            return false;
        
        return left.Equals(right);
    }
    
    public static bool operator !=(ValueObject? left, ValueObject? right)
    {
        return !(left == right);
    }
}
```

**Delete default Class1.cs**:
```bash
rm src/LLMGateway.Domain/Class1.cs
```

---

### Step 2: Implement ModelName Value Object (10 minutes)

**File**: `src/LLMGateway.Domain/ValueObjects/ModelName.cs`

```csharp
namespace LLMGateway.Domain.ValueObjects;

public sealed class ModelName : ValueObject
{
    public string Value { get; }
    public string Provider { get; }
    
    private ModelName(string value)
    {
        Value = value;
        Provider = ExtractProvider(value);
    }
    
    public static ModelName From(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException(
                "Model name cannot be null or empty", 
                nameof(value));
        
        return new ModelName(value);
    }
    
    private static string ExtractProvider(string modelName)
    {
        // Format: "provider/model-name" (e.g., "z-ai/glm-4.6")
        var parts = modelName.Split('/', 2);
        return parts.Length > 1 ? parts[0] : "unknown";
    }
    
    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Value;
    }
    
    public override string ToString() => Value;
}
```

---

### Step 3: Implement TokenCount Value Object (10 minutes)

**File**: `src/LLMGateway.Domain/ValueObjects/TokenCount.cs`

```csharp
namespace LLMGateway.Domain.ValueObjects;

public sealed class TokenCount : ValueObject
{
    public int Value { get; }
    
    private TokenCount(int value)
    {
        if (value < 0)
            throw new ArgumentException(
                "Token count cannot be negative", 
                nameof(value));
        
        Value = value;
    }
    
    public static TokenCount From(int value) => new(value);
    
    public static TokenCount EstimateFromText(string text)
    {
        if (string.IsNullOrEmpty(text))
            return new TokenCount(0);
        
        // Simple estimation: ~4 characters per token
        // This is approximate - real tokenizers vary by model
        var estimatedTokens = text.Length / 4;
        return new TokenCount(estimatedTokens);
    }
    
    public bool ExceedsLimit(int maxTokens) => Value > maxTokens;
    
    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Value;
    }
    
    public override string ToString() => Value.ToString();
}
```

---

### Step 4: Implement CostAmount Value Object (10 minutes)

**File**: `src/LLMGateway.Domain/ValueObjects/CostAmount.cs`

```csharp
namespace LLMGateway.Domain.ValueObjects;

public sealed class CostAmount : ValueObject
{
    public decimal ValueUsd { get; }
    
    private CostAmount(decimal valueUsd)
    {
        if (valueUsd < 0)
            throw new ArgumentException(
                "Cost cannot be negative", 
                nameof(valueUsd));
        
        // Round to 6 decimal places for micro-cost precision
        ValueUsd = Math.Round(valueUsd, 6);
    }
    
    public static CostAmount FromUsd(decimal value) => new(value);
    
    public static CostAmount Zero => new(0);
    
    public CostAmount Add(CostAmount other) 
        => new(ValueUsd + other.ValueUsd);
    
    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return ValueUsd;
    }
    
    public override string ToString() => $"${ValueUsd:F6}";
}
```

---

### Step 5: Implement RequestLog Entity (15 minutes)

**Create folder**: `src/LLMGateway.Domain/Entities/`

**File**: `src/LLMGateway.Domain/Entities/RequestLog.cs`

```csharp
using LLMGateway.Domain.ValueObjects;

namespace LLMGateway.Domain.Entities;

public class RequestLog
{
    public Guid Id { get; private set; }
    public DateTime Timestamp { get; private set; }
    public ModelName ModelUsed { get; private set; }
    public TokenCount InputTokens { get; private set; }
    public TokenCount OutputTokens { get; private set; }
    public CostAmount EstimatedCost { get; private set; }
    public string ProviderName { get; private set; }
    public TimeSpan ResponseTime { get; private set; }
    public bool WasFallback { get; private set; }
    
    // Private constructor for EF Core
    private RequestLog() 
    {
        ModelUsed = null!;
        ProviderName = null!;
    }
    
    // Factory method enforces invariants
    public static RequestLog Create(
        ModelName model,
        TokenCount inputTokens,
        TokenCount outputTokens,
        CostAmount cost,
        string provider,
        TimeSpan responseTime,
        bool wasFallback = false)
    {
        if (model == null)
            throw new ArgumentNullException(nameof(model));
        
        if (inputTokens == null)
            throw new ArgumentNullException(nameof(inputTokens));
        
        if (outputTokens == null)
            throw new ArgumentNullException(nameof(outputTokens));
        
        if (cost == null)
            throw new ArgumentNullException(nameof(cost));
        
        if (string.IsNullOrWhiteSpace(provider))
            throw new ArgumentException(
                "Provider name cannot be empty", 
                nameof(provider));
        
        if (responseTime < TimeSpan.Zero)
            throw new ArgumentException(
                "Response time cannot be negative", 
                nameof(responseTime));
        
        return new RequestLog
        {
            Id = Guid.NewGuid(),
            Timestamp = DateTime.UtcNow,
            ModelUsed = model,
            InputTokens = inputTokens,
            OutputTokens = outputTokens,
            EstimatedCost = cost,
            ProviderName = provider,
            ResponseTime = responseTime,
            WasFallback = wasFallback
        };
    }
    
    public TokenCount TotalTokens() 
        => TokenCount.From(InputTokens.Value + OutputTokens.Value);
}
```

---

### Step 6: Implement ModelPricing Entity (15 minutes)

**File**: `src/LLMGateway.Domain/Entities/ModelPricing.cs`

```csharp
using LLMGateway.Domain.ValueObjects;

namespace LLMGateway.Domain.Entities;

public class ModelPricing
{
    public Guid Id { get; private set; }
    public ModelName Model { get; private set; }
    public string ProviderName { get; private set; }
    public decimal InputCostPer1MTokens { get; private set; }
    public decimal OutputCostPer1MTokens { get; private set; }
    public int MaxContextTokens { get; private set; }
    public DateTime UpdatedAt { get; private set; }
    
    // Private constructor for EF Core
    private ModelPricing() 
    {
        Model = null!;
        ProviderName = null!;
    }
    
    public static ModelPricing Create(
        ModelName model,
        string provider,
        decimal inputCost,
        decimal outputCost,
        int maxTokens)
    {
        if (model == null)
            throw new ArgumentNullException(nameof(model));
        
        if (string.IsNullOrWhiteSpace(provider))
            throw new ArgumentException(
                "Provider name cannot be empty", 
                nameof(provider));
        
        if (inputCost < 0)
            throw new ArgumentException(
                "Input cost cannot be negative", 
                nameof(inputCost));
        
        if (outputCost < 0)
            throw new ArgumentException(
                "Output cost cannot be negative", 
                nameof(outputCost));
        
        if (maxTokens <= 0)
            throw new ArgumentException(
                "Max tokens must be positive", 
                nameof(maxTokens));
        
        return new ModelPricing
        {
            Id = Guid.NewGuid(),
            Model = model,
            ProviderName = provider,
            InputCostPer1MTokens = inputCost,
            OutputCostPer1MTokens = outputCost,
            MaxContextTokens = maxTokens,
            UpdatedAt = DateTime.UtcNow
        };
    }
    
    public CostAmount CalculateCost(TokenCount input, TokenCount output)
    {
        if (input == null)
            throw new ArgumentNullException(nameof(input));
        
        if (output == null)
            throw new ArgumentNullException(nameof(output));
        
        var inputCost = (input.Value / 1_000_000m) * InputCostPer1MTokens;
        var outputCost = (output.Value / 1_000_000m) * OutputCostPer1MTokens;
        
        return CostAmount.FromUsd(inputCost + outputCost);
    }
}
```

---

### Step 7: Create Repository Interfaces (10 minutes)

**Create folder**: `src/LLMGateway.Domain/Interfaces/`

**File**: `src/LLMGateway.Domain/Interfaces/IRequestLogRepository.cs`

```csharp
using LLMGateway.Domain.Entities;
using LLMGateway.Domain.ValueObjects;

namespace LLMGateway.Domain.Interfaces;

public interface IRequestLogRepository
{
    Task<RequestLog> SaveAsync(
        RequestLog log, 
        CancellationToken cancellationToken = default);
    
    Task<IEnumerable<RequestLog>> GetRecentAsync(
        int count, 
        CancellationToken cancellationToken = default);
    
    Task<CostAmount> GetTotalCostAsync(
        DateTime since, 
        CancellationToken cancellationToken = default);
}
```

**File**: `src/LLMGateway.Domain/Interfaces/IModelPricingRepository.cs`

```csharp
using LLMGateway.Domain.Entities;
using LLMGateway.Domain.ValueObjects;

namespace LLMGateway.Domain.Interfaces;

public interface IModelPricingRepository
{
    Task<ModelPricing?> GetByModelAsync(
        ModelName model, 
        CancellationToken cancellationToken = default);
    
    Task<IEnumerable<ModelPricing>> GetAllAsync(
        CancellationToken cancellationToken = default);
}
```

**File**: `src/LLMGateway.Domain/Interfaces/IProviderHealthChecker.cs`

```csharp
namespace LLMGateway.Domain.Interfaces;

public interface IProviderHealthChecker
{
    Task<bool> IsHealthyAsync(
        string providerName, 
        CancellationToken cancellationToken = default);
    
    Task<Dictionary<string, bool>> CheckAllProvidersAsync(
        CancellationToken cancellationToken = default);
}
```

---

### Step 8: Create Domain Exceptions (10 minutes)

**Create folder**: `src/LLMGateway.Domain/Exceptions/`

**File**: `src/LLMGateway.Domain/Exceptions/AllProvidersFailedException.cs`

```csharp
namespace LLMGateway.Domain.Exceptions;

public class AllProvidersFailedException : Exception
{
    public IReadOnlyList<string> AttemptedProviders { get; }
    
    public AllProvidersFailedException(IReadOnlyList<string> providers)
        : base($"All providers failed: {string.Join(", ", providers)}")
    {
        AttemptedProviders = providers;
    }
}
```

**File**: `src/LLMGateway.Domain/Exceptions/TokenLimitExceededException.cs`

```csharp
using LLMGateway.Domain.ValueObjects;

namespace LLMGateway.Domain.Exceptions;

public class TokenLimitExceededException : Exception
{
    public TokenCount RequestedTokens { get; }
    public int MaxTokens { get; }
    
    public TokenLimitExceededException(TokenCount requested, int max)
        : base($"Token count {requested.Value} exceeds limit {max}")
    {
        RequestedTokens = requested;
        MaxTokens = max;
    }
}
```

**File**: `src/LLMGateway.Domain/Exceptions/ModelNotFoundException.cs`

```csharp
using LLMGateway.Domain.ValueObjects;

namespace LLMGateway.Domain.Exceptions;

public class ModelNotFoundException : Exception
{
    public ModelName RequestedModel { get; }
    
    public ModelNotFoundException(ModelName model)
        : base($"Model '{model.Value}' not found in any provider")
    {
        RequestedModel = model;
    }
}
```

---

### Step 9: Create Domain Constants (5 minutes)

**Create folder**: `src/LLMGateway.Domain/Constants/`

**File**: `src/LLMGateway.Domain/Constants/ModelDefaults.cs`

```csharp
namespace LLMGateway.Domain.Constants;

public static class ModelDefaults
{
    // Model identifiers (OpenRouter format)
    public const string DefaultModel = "z-ai/glm-4.6";
    public const string LargeContextModel = "moonshotai/Kimi-K2-Instruct-0905";
    public const string BalancedModel = "deepseek-ai/DeepSeek-V3.1-Terminus";
    
    // Context thresholds for routing
    public const int StandardContextLimit = 10_000;
    public const int LargeContextLimit = 200_000;
    
    // Fallback chain (circular with cycle detection)
    public static readonly string[] FallbackChain = new[]
    {
        DefaultModel,
        BalancedModel,
        LargeContextModel
    };
}
```

---

### Step 10: Write Unit Tests (30 minutes)

**Delete default test file**:
```bash
rm tests/LLMGateway.Domain.Tests/UnitTest1.cs
```

**Create folder**: `tests/LLMGateway.Domain.Tests/ValueObjects/`

**File**: `tests/LLMGateway.Domain.Tests/ValueObjects/ModelNameTests.cs`

```csharp
using FluentAssertions;
using LLMGateway.Domain.ValueObjects;

namespace LLMGateway.Domain.Tests.ValueObjects;

public class ModelNameTests
{
    [Fact]
    public void From_ValidModelName_CreatesInstance()
    {
        // Act
        var modelName = ModelName.From("z-ai/glm-4.6");
        
        // Assert
        modelName.Value.Should().Be("z-ai/glm-4.6");
        modelName.Provider.Should().Be("z-ai");
    }
    
    [Theory]
    [InlineData(null)]
    [InlineData("")]
    [InlineData("   ")]
    public void From_InvalidModelName_ThrowsArgumentException(string? invalid)
    {
        // Act
        var act = () => ModelName.From(invalid!);
        
        // Assert
        act.Should().Throw<ArgumentException>()
            .WithMessage("*cannot be null or empty*");
    }
    
    [Fact]
    public void From_ModelNameWithoutSlash_ExtractsUnknownProvider()
    {
        // Act
        var modelName = ModelName.From("gpt-4");
        
        // Assert
        modelName.Value.Should().Be("gpt-4");
        modelName.Provider.Should().Be("unknown");
    }
    
    [Fact]
    public void Equals_SameValue_ReturnsTrue()
    {
        // Arrange
        var model1 = ModelName.From("z-ai/glm-4.6");
        var model2 = ModelName.From("z-ai/glm-4.6");
        
        // Act & Assert
        model1.Should().Be(model2);
        (model1 == model2).Should().BeTrue();
    }
    
    [Fact]
    public void Equals_DifferentValue_ReturnsFalse()
    {
        // Arrange
        var model1 = ModelName.From("z-ai/glm-4.6");
        var model2 = ModelName.From("moonshotai/Kimi-K2");
        
        // Act & Assert
        model1.Should().NotBe(model2);
        (model1 != model2).Should().BeTrue();
    }
}
```

**File**: `tests/LLMGateway.Domain.Tests/ValueObjects/TokenCountTests.cs`

```csharp
using FluentAssertions;
using LLMGateway.Domain.ValueObjects;

namespace LLMGateway.Domain.Tests.ValueObjects;

public class TokenCountTests
{
    [Fact]
    public void From_ValidCount_CreatesInstance()
    {
        // Act
        var tokens = TokenCount.From(100);
        
        // Assert
        tokens.Value.Should().Be(100);
    }
    
    [Fact]
    public void From_NegativeCount_ThrowsArgumentException()
    {
        // Act
        var act = () => TokenCount.From(-1);
        
        // Assert
        act.Should().Throw<ArgumentException>()
            .WithMessage("*cannot be negative*");
    }
    
    [Theory]
    [InlineData("Hello world", 2)]      // 11 chars / 4 = 2
    [InlineData("Test", 1)]              // 4 chars / 4 = 1
    [InlineData("", 0)]                  // Empty = 0
    [InlineData("A very long text with many words", 8)] // 34 chars / 4 = 8
    public void EstimateFromText_CalculatesApproximateTokens(
        string text, 
        int expectedTokens)
    {
        // Act
        var tokens = TokenCount.EstimateFromText(text);
        
        // Assert
        tokens.Value.Should().Be(expectedTokens);
    }
    
    [Fact]
    public void ExceedsLimit_TokensAboveLimit_ReturnsTrue()
    {
        // Arrange
        var tokens = TokenCount.From(15000);
        
        // Act
        var exceeds = tokens.ExceedsLimit(10000);
        
        // Assert
        exceeds.Should().BeTrue();
    }
    
    [Fact]
    public void ExceedsLimit_TokensBelowLimit_ReturnsFalse()
    {
        // Arrange
        var tokens = TokenCount.From(5000);
        
        // Act
        var exceeds = tokens.ExceedsLimit(10000);
        
        // Assert
        exceeds.Should().BeFalse();
    }
}
```

**File**: `tests/LLMGateway.Domain.Tests/ValueObjects/CostAmountTests.cs`

```csharp
using FluentAssertions;
using LLMGateway.Domain.ValueObjects;

namespace LLMGateway.Domain.Tests.ValueObjects;

public class CostAmountTests
{
    [Fact]
    public void FromUsd_ValidAmount_CreatesInstance()
    {
        // Act
        var cost = CostAmount.FromUsd(0.123456m);
        
        // Assert
        cost.ValueUsd.Should().Be(0.123456m);
    }
    
    [Fact]
    public void FromUsd_NegativeAmount_ThrowsArgumentException()
    {
        // Act
        var act = () => CostAmount.FromUsd(-0.01m);
        
        // Assert
        act.Should().Throw<ArgumentException>()
            .WithMessage("*cannot be negative*");
    }
    
    [Fact]
    public void FromUsd_RoundsToSixDecimalPlaces()
    {
        // Act
        var cost = CostAmount.FromUsd(0.1234567890m);
        
        // Assert
        cost.ValueUsd.Should().Be(0.123457m); // Rounded
    }
    
    [Fact]
    public void Zero_ReturnsZeroCost()
    {
        // Act
        var cost = CostAmount.Zero;
        
        // Assert
        cost.ValueUsd.Should().Be(0m);
    }
    
    [Fact]
    public void Add_TwoCosts_ReturnsSum()
    {
        // Arrange
        var cost1 = CostAmount.FromUsd(0.000001m);
        var cost2 = CostAmount.FromUsd(0.000002m);
        
        // Act
        var total = cost1.Add(cost2);
        
        // Assert
        total.ValueUsd.Should().Be(0.000003m);
    }
}
```

**Create folder**: `tests/LLMGateway.Domain.Tests/Entities/`

**File**: `tests/LLMGateway.Domain.Tests/Entities/RequestLogTests.cs`

```csharp
using FluentAssertions;
using LLMGateway.Domain.Entities;
using LLMGateway.Domain.ValueObjects;

namespace LLMGateway.Domain.Tests.Entities;

public class RequestLogTests
{
    [Fact]
    public void Create_ValidParameters_CreatesRequestLog()
    {
        // Arrange
        var model = ModelName.From("z-ai/glm-4.6");
        var inputTokens = TokenCount.From(10);
        var outputTokens = TokenCount.From(50);
        var cost = CostAmount.FromUsd(0.00001m);
        var responseTime = TimeSpan.FromMilliseconds(1234);
        
        // Act
        var log = RequestLog.Create(
            model, 
            inputTokens, 
            outputTokens, 
            cost, 
            "OpenRouter", 
            responseTime);
        
        // Assert
        log.Id.Should().NotBeEmpty();
        log.Timestamp.Should().BeCloseTo(DateTime.UtcNow, TimeSpan.FromSeconds(1));
        log.ModelUsed.Should().Be(model);
        log.InputTokens.Should().Be(inputTokens);
        log.OutputTokens.Should().Be(outputTokens);
        log.EstimatedCost.Should().Be(cost);
        log.ProviderName.Should().Be("OpenRouter");
        log.ResponseTime.Should().Be(responseTime);
        log.WasFallback.Should().BeFalse();
    }
    
    [Fact]
    public void Create_NullModel_ThrowsArgumentNullException()
    {
        // Act
        var act = () => RequestLog.Create(
            null!, 
            TokenCount.From(10), 
            TokenCount.From(50), 
            CostAmount.FromUsd(0.01m), 
            "OpenRouter", 
            TimeSpan.FromSeconds(1));
        
        // Assert
        act.Should().Throw<ArgumentNullException>();
    }
    
    [Fact]
    public void TotalTokens_ReturnsInputPlusOutput()
    {
        // Arrange
        var log = RequestLog.Create(
            ModelName.From("z-ai/glm-4.6"),
            TokenCount.From(10),
            TokenCount.From(50),
            CostAmount.FromUsd(0.01m),
            "OpenRouter",
            TimeSpan.FromSeconds(1));
        
        // Act
        var total = log.TotalTokens();
        
        // Assert
        total.Value.Should().Be(60);
    }
}
```

**File**: `tests/LLMGateway.Domain.Tests/Entities/ModelPricingTests.cs`

```csharp
using FluentAssertions;
using LLMGateway.Domain.Entities;
using LLMGateway.Domain.ValueObjects;

namespace LLMGateway.Domain.Tests.Entities;

public class ModelPricingTests
{
    [Fact]
    public void Create_ValidParameters_CreatesModelPricing()
    {
        // Arrange
        var model = ModelName.From("z-ai/glm-4.6");
        
        // Act
        var pricing = ModelPricing.Create(
            model,
            "OpenRouter",
            inputCost: 0.0001m,
            outputCost: 0.0002m,
            maxTokens: 128_000);
        
        // Assert
        pricing.Id.Should().NotBeEmpty();
        pricing.Model.Should().Be(model);
        pricing.ProviderName.Should().Be("OpenRouter");
        pricing.InputCostPer1MTokens.Should().Be(0.0001m);
        pricing.OutputCostPer1MTokens.Should().Be(0.0002m);
        pricing.MaxContextTokens.Should().Be(128_000);
        pricing.UpdatedAt.Should().BeCloseTo(DateTime.UtcNow, TimeSpan.FromSeconds(1));
    }
    
    [Fact]
    public void CalculateCost_ValidTokens_ReturnsCorrectCost()
    {
        // Arrange
        var pricing = ModelPricing.Create(
            ModelName.From("z-ai/glm-4.6"),
            "OpenRouter",
            inputCost: 0.0001m,   // $0.0001 per 1M tokens
            outputCost: 0.0002m,  // $0.0002 per 1M tokens
            maxTokens: 128_000);
        
        var inputTokens = TokenCount.From(1_000_000);  // 1M tokens
        var outputTokens = TokenCount.From(1_000_000); // 1M tokens
        
        // Act
        var cost = pricing.CalculateCost(inputTokens, outputTokens);
        
        // Assert
        // Input: (1,000,000 / 1,000,000) * 0.0001 = $0.0001
        // Output: (1,000,000 / 1,000,000) * 0.0002 = $0.0002
        // Total: $0.0003
        cost.ValueUsd.Should().Be(0.0003m);
    }
    
    [Fact]
    public void CalculateCost_SmallTokenCount_CalculatesMicroCost()
    {
        // Arrange
        var pricing = ModelPricing.Create(
            ModelName.From("z-ai/glm-4.6"),
            "OpenRouter",
            inputCost: 0.0001m,
            outputCost: 0.0002m,
            maxTokens: 128_000);
        
        var inputTokens = TokenCount.From(5);    // Tiny request
        var outputTokens = TokenCount.From(150);
        
        // Act
        var cost = pricing.CalculateCost(inputTokens, outputTokens);
        
        // Assert
        // Input: (5 / 1,000,000) * 0.0001 = $0.0000000005
        // Output: (150 / 1,000,000) * 0.0002 = $0.00000003
        // Total: $0.0000000305 → rounded to $0.000000 (6 decimals)
        cost.ValueUsd.Should().BeGreaterThan(0);
    }
}
```

---

### Step 11: Verify Build and Tests (5 minutes)

```bash
# Build Domain project (should have zero dependencies)
dotnet build src/LLMGateway.Domain

# Expected output: Build succeeded. 0 Warning(s). 0 Error(s).

# Run Domain tests
dotnet test tests/LLMGateway.Domain.Tests

# Expected output: All tests passed
```

**Verify zero dependencies**:
```bash
cat src/LLMGateway.Domain/LLMGateway.Domain.csproj
```

Expected content:
```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <!-- NO <ItemGroup> with PackageReference - Domain must be pure -->
</Project>
```

---

### Step 12: Commit Changes (5 minutes)

```bash
# Stage all Domain layer files
git add src/LLMGateway.Domain/
git add tests/LLMGateway.Domain.Tests/

# Commit with descriptive message
git commit -m "feat: Implement Domain layer (US-002)

- Add ValueObject base class with equality logic
- Implement ModelName, TokenCount, CostAmount value objects
- Implement RequestLog, ModelPricing entities with factory methods
- Define repository interfaces (IRequestLogRepository, IModelPricingRepository, IProviderHealthChecker)
- Add domain exceptions (AllProvidersFailedException, TokenLimitExceededException, ModelNotFoundException)
- Add ModelDefaults constants (fallback chain, thresholds)
- Add comprehensive unit tests for value objects and entities

Domain layer has ZERO external dependencies (pure C#)"

# Push to GitHub
git push
```

---

## Verification Steps

**Run these commands to verify US-002 completion:**

```bash
# 1. Domain project builds independently
dotnet build src/LLMGateway.Domain
# Expected: Build succeeded

# 2. Domain has zero NuGet dependencies
grep -c "PackageReference" src/LLMGateway.Domain/LLMGateway.Domain.csproj
# Expected: 0

# 3. All domain tests pass
dotnet test tests/LLMGateway.Domain.Tests --logger "console;verbosity=detailed"
# Expected: Passed! - Failed: 0, Passed: 15+, Skipped: 0

# 4. Test coverage on value objects
dotnet test tests/LLMGateway.Domain.Tests --collect:"XPlat Code Coverage"
# Expected: High coverage on ValueObjects and Entities folders

# 5. Solution still compiles
dotnet build
# Expected: Build succeeded (all projects)

# 6. Git status clean
git status
# Expected: nothing to commit, working tree clean
```

---

## Definition of Done

- [x] `ValueObject` base class with `==`, `!=`, `Equals()`, `GetHashCode()` implemented
- [x] `ModelName` value object with provider extraction and validation
- [x] `TokenCount` value object with `EstimateFromText()` and `ExceedsLimit()`
- [x] `CostAmount` value object with 6-decimal precision and `Add()` method
- [x] `RequestLog` entity with private constructor and `Create()` factory method
- [x] `ModelPricing` entity with `CalculateCost()` method
- [x] `IRequestLogRepository`, `IModelPricingRepository`, `IProviderHealthChecker` interfaces defined
- [x] Domain exceptions with descriptive messages and properties
- [x] `ModelDefaults` constants matching ADR-003 routing strategy
- [x] Domain project has **zero NuGet dependencies**
- [x] All unit tests pass (15+ tests)
- [x] Test coverage ≥80% on value objects and entities
- [x] Code committed to GitHub with descriptive message

---

## File Structure After US-002

```
src/LLMGateway.Domain/
├── Constants/
│   └── ModelDefaults.cs
├── Entities/
│   ├── RequestLog.cs
│   └── ModelPricing.cs
├── Exceptions/
│   ├── AllProvidersFailedException.cs
│   ├── TokenLimitExceededException.cs
│   └── ModelNotFoundException.cs
├── Interfaces/
│   ├── IRequestLogRepository.cs
│   ├── IModelPricingRepository.cs
│   └── IProviderHealthChecker.cs
├── ValueObjects/
│   ├── ValueObject.cs          # Base class
│   ├── ModelName.cs
│   ├── TokenCount.cs
│   └── CostAmount.cs
└── LLMGateway.Domain.csproj    # ZERO dependencies

tests/LLMGateway.Domain.Tests/
├── Entities/
│   ├── RequestLogTests.cs
│   └── ModelPricingTests.cs
├── ValueObjects/
│   ├── ModelNameTests.cs
│   ├── TokenCountTests.cs
│   └── CostAmountTests.cs
└── LLMGateway.Domain.Tests.csproj
```

---

## Troubleshooting

**Issue: Domain project references external packages**
```bash
# Remove any accidental package references
dotnet remove src/LLMGateway.Domain package [PackageName]

# Verify clean
cat src/LLMGateway.Domain/LLMGateway.Domain.csproj
```

**Issue: Value object equality tests fail**
```csharp
// Ensure GetEqualityComponents() is implemented correctly
protected override IEnumerable<object> GetEqualityComponents()
{
    yield return Value; // Must yield ALL value properties
}
```

**Issue: Entity factory method validation not working**
```csharp
// Ensure ArgumentNullException is thrown BEFORE object creation
if (model == null)
    throw new ArgumentNullException(nameof(model));

// NOT after:
return new RequestLog { Model = model }; // Too late!
```

**Issue: Test project can't find Domain types**
```bash
# Verify test project references Domain
dotnet list tests/LLMGateway.Domain.Tests reference
# Should show: ../src/LLMGateway.Domain/LLMGateway.Domain.csproj
```

**Issue: FluentAssertions syntax errors**
```bash
# Ensure FluentAssertions package installed
dotnet add tests/LLMGateway.Domain.Tests package FluentAssertions

# Add using statement
using FluentAssertions;
```

---

## Key Learnings for Next US

**What worked well:**
- Value objects enforce validation at creation
- Factory methods prevent invalid entities
- Immutability prevents accidental mutation
- Repository interfaces enable testability

**Patterns to continue:**
- Private constructors + factory methods for entities
- Value objects for domain concepts (not primitives)
- Interfaces in Domain, implementations in Infrastructure
- Comprehensive unit tests for business rules

**Ready for US-003:**
- Application layer can now reference Domain types
- Plugins will use value objects (ModelName, TokenCount, CostAmount)
- KernelOrchestrator will use repository interfaces
- No coupling to Infrastructure yet (still pure interfaces)

---

## Time Estimate

- ValueObject base class: **5 minutes**
- Value objects (3 classes): **30 minutes** (10 min each)
- Entities (2 classes): **30 minutes** (15 min each)
- Repository interfaces (3 interfaces): **10 minutes**
- Domain exceptions (3 classes): **10 minutes**
- Constants: **5 minutes**
- Unit tests (5 test classes): **30 minutes**
- Verification & commit: **10 minutes**
- **Total: ~2 hours**

---

## Next Steps

Once US-002 is complete:
- **US-003:** Implement Application layer (KernelOrchestrator, KernelFactory, 3 plugins)
- **US-004:** Implement Infrastructure layer (OpenRouterChatCompletionService, EF Core repositories)
- **US-005:** Implement API layer (ChatCompletionController, middleware, Program.cs)
- **US-006:** End-to-end integration testing

---

## Success Criteria Summary

✅ **Domain layer is complete when:**
1. All 15+ unit tests pass
2. Domain.csproj has zero PackageReference entries
3. Value objects validate input and enforce immutability
4. Entities use factory methods to prevent invalid state
5. Repository interfaces define contracts for Infrastructure
6. Constants match ADR-003 routing strategy
7. Code is committed to GitHub