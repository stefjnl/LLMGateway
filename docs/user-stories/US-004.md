# US-004: Infrastructure Layer Implementation

---

## User Story

**As a** developer  
**I want to** implement the Infrastructure layer with OpenRouter integration, EF Core persistence, and Polly resilience  
**So that** the application layer can interact with real external services instead of in-memory mocks

---

## Context

Domain (US-002) and Application (US-003/003B) layers are complete with in-memory repositories. Now we need real implementations that talk to external systems:
- OpenRouter API for LLM completions
- PostgreSQL for request logs and model pricing
- Health checks for provider availability

**Critical Design Constraint**: OpenRouterChatCompletionService must manually populate SK metadata (`input_tokens`, `output_tokens`) because Application layer expects this data for cost calculation.

---

## Acceptance Criteria

### ✅ Criterion 1: OpenRouterChatCompletionService Implementation
- [ ] Implements `IChatCompletionService` from Semantic Kernel
- [ ] Makes HTTP POST to `https://openrouter.ai/api/v1/chat/completions`
- [ ] Extracts `model` and `temperature` from `PromptExecutionSettings.ExtensionData`
- [ ] Builds OpenAI-compatible request payload (messages, model, temperature, max_tokens)
- [ ] **CRITICAL**: Populates `ChatMessageContent.Metadata` with:
  - `["input_tokens"]` from response.usage.prompt_tokens
  - `["output_tokens"]` from response.usage.completion_tokens
- [ ] Throws `HttpRequestException` with status codes for transient errors (429, 500-504)
- [ ] Handles non-transient errors gracefully (401, 400)
- [ ] Includes required headers: `Authorization: Bearer {API_KEY}`
- [ ] Logs requests/responses at appropriate levels (Information for success, Warning for retries, Error for failures)

### ✅ Criterion 2: Polly Resilience Policies
- [ ] **Retry Policy**: 3 attempts with exponential backoff (1s, 2s, 4s)
- [ ] Retry only on transient errors: 429, 500-504 status codes, `TaskCanceledException`
- [ ] **Circuit Breaker**: Opens after 5 consecutive failures, 30s cooldown
- [ ] Logs policy events (retry attempt, circuit opened/closed)
- [ ] Policies applied to `HttpClient` via DI registration

### ✅ Criterion 3: EF Core DbContext Configuration
- [ ] `GatewayDbContext` with `DbSet<RequestLog>` and `DbSet<ModelPricing>`
- [ ] Uses `ApplyConfigurationsFromAssembly()` for entity configs
- [ ] Connection string read from `IConfiguration` ("PostgreSQL")
- [ ] Specifies migrations assembly in `UseNpgsql()`

### ✅ Criterion 4: Entity Configurations (snake_case naming)
- [ ] **RequestLogConfiguration**:
  - Maps `ModelUsed` value object using `OwnsOne` (columns: `model_used`, `model_provider`)
  - Maps `InputTokens`, `OutputTokens`, `EstimatedCost` value objects similarly
  - Primary key: `id` (uuid)
  - Indexes on `timestamp`, `provider_name`
- [ ] **ModelPricingConfiguration**:
  - Maps `Model` value object using `OwnsOne`
  - Unique index on `model_name`
  - Columns: `input_cost_per_1m_tokens`, `output_cost_per_1m_tokens`, `max_context_tokens`
- [ ] All column names in snake_case (e.g., `response_time_ms`, not `ResponseTimeMs`)

### ✅ Criterion 5: Repository Implementations
- [ ] **RequestLogRepository** implements `IRequestLogRepository`:
  - `SaveAsync()`: Persists via EF Core, returns saved entity
  - `GetRecentAsync()`: Orders by timestamp DESC, takes N records
  - `GetTotalCostAsync()`: Sums `EstimatedCost.ValueUsd` for logs since given date
- [ ] **ModelPricingRepository** implements `IModelPricingRepository`:
  - `GetByModelAsync()`: Queries by `ModelName.Value`, returns null if not found
  - `GetAllAsync()`: Returns all pricing records
- [ ] **ProviderHealthChecker** implements `IProviderHealthChecker`:
  - `IsHealthyAsync()`: Calls OpenRouter `/models` endpoint with 5s timeout
  - `CheckAllProvidersAsync()`: Returns dict {"OpenRouter": true/false}
  - Returns false on timeout/exception (logs warning)

### ✅ Criterion 6: EF Core Migration with Seed Data
- [ ] Initial migration creates both tables with correct schema
- [ ] Seed data for ModelPricing (3 models):
  - `z-ai/glm-4.6`: $0.0001/$0.0002 per 1M tokens, 128K context
  - `deepseek-ai/DeepSeek-V3.1-Terminus`: $0.0003/$0.0005, 64K context
  - `moonshotai/Kimi-K2-Instruct-0905`: $0.0005/$0.0010, 200K context
- [ ] Migration can run cleanly on empty PostgreSQL database

### ✅ Criterion 7: DI Registration Extension
- [ ] `SKServiceCollectionExtensions.AddInfrastructure(IConfiguration)` method
- [ ] Registers `IChatCompletionService` as `OpenRouterChatCompletionService` (singleton)
- [ ] Registers repositories as scoped services
- [ ] Registers `IProviderHealthChecker` as singleton
- [ ] Configures `HttpClient` for `OpenRouterChatCompletionService` with:
  - Base address from config
  - Timeout from config (default 30s)
  - Polly policies attached
- [ ] Registers EF Core `GatewayDbContext` with connection string
- [ ] Registers plugins (ModelSelection, CostTracking, ProviderFallback) - depends on repositories
- [ ] Registers `KernelFactory`

### ✅ Criterion 8: Unit Tests Pass
- [ ] **OpenRouterChatCompletionService tests** (mock HttpClient):
  - Successful completion with metadata population
  - Retry on 429/500 status codes
  - Circuit breaker opens after 5 failures
  - Non-transient errors (401, 400) don't retry
  - Model/temperature extraction from ExtensionData
- [ ] **Repository tests** (in-memory SQLite):
  - Save and retrieve RequestLog with value objects
  - Query ModelPricing by ModelName
  - GetTotalCost aggregation
  - Health checker timeout handling
- [ ] **Integration test**: Full orchestration with real Kernel + mocked HTTP (verify metadata flows correctly)

---

## Prerequisites

**Completed:**
- ✅ US-001: Project structure
- ✅ US-002: Domain layer (entities, value objects, interfaces)
- ✅ US-003/003B: Application layer (orchestrator, plugins, DTOs)

**Required Knowledge:**
- Semantic Kernel IChatCompletionService contract
- EF Core value object mapping (OwnsOne, HasConversion)
- Polly resilience policies (Retry, Circuit Breaker)
- PostgreSQL conventions (snake_case)
- HttpClient best practices in .NET

**External Dependencies:**
- OpenRouter API key (register at https://openrouter.ai/)
- PostgreSQL instance (Docker or local)
- NuGet packages: Npgsql.EntityFrameworkCore.PostgreSQL, Microsoft.Extensions.Http.Polly, Microsoft.SemanticKernel

---

## Architecture Impact

**Replaces In-Memory Implementations:**
- `InMemoryRequestLogRepository` → `RequestLogRepository` (EF Core)
- `InMemoryModelPricingRepository` → `ModelPricingRepository` (EF Core)
- Mock chat completion → `OpenRouterChatCompletionService` (real HTTP)

**New Dependencies:**
- Infrastructure → Domain (implements interfaces)
- Infrastructure → Application (NOT ALLOWED - violates Clean Architecture)
- Infrastructure uses value objects from Domain (ModelName, TokenCount, CostAmount)

**Dependency Injection Flow:**
```
API Layer (Program.cs)
  → calls AddInfrastructure(config)
    → registers OpenRouterChatCompletionService (IChatCompletionService)
    → registers repositories (IRequestLogRepository, etc.)
    → registers EF Core context
    → configures Polly on HttpClient
  → calls AddApplication() [if not already called in US-003]
    → registers plugins (now get real repositories from DI)
    → registers KernelFactory, KernelOrchestrator
```

---

## Critical Implementation Details

### 1. OpenRouter API Request/Response Format

**Request** (verify against OpenRouter docs):
```json
{
  "model": "z-ai/glm-4.6",
  "messages": [
    {"role": "user", "content": "Hello"}
  ],
  "temperature": 0.7,
  "max_tokens": 2000
}
```

**Response** (critical: verify usage object structure):
```json
{
  "id": "chatcmpl-...",
  "model": "z-ai/glm-4.6",
  "choices": [{
    "message": {
      "role": "assistant",
      "content": "Hi there!"
    },
    "finish_reason": "stop"
  }],
  "usage": {
    "prompt_tokens": 10,
    "completion_tokens": 5,
    "total_tokens": 15
  }
}
```

**⚠️ Action Item**: Test with real OpenRouter API to confirm response structure matches assumption. Application layer will break if `usage.prompt_tokens` doesn't exist.

### 2. SK Metadata Population Pattern

```csharp
// Application layer expects this structure:
result.Metadata = new Dictionary<string, object?>
{
    ["input_tokens"] = responseUsage.PromptTokens,
    ["output_tokens"] = responseUsage.CompletionTokens
};
```

Without this, Application layer's token extraction falls back to estimation (less accurate cost tracking).

### 3. Value Object Persistence (EF Core)

**Challenge**: Domain value objects (ModelName, TokenCount, CostAmount) must be mapped to primitive columns.

**Solution**: Use `OwnsOne` with property mapping:
```csharp
builder.OwnsOne(e => e.ModelUsed, mb => {
    mb.Property(m => m.Value).HasColumnName("model_used");
    mb.Property(m => m.Provider).HasColumnName("model_provider");
});
```

**Avoid**: HasConversion for complex objects (loses FK support, harder to query).

### 4. Transient Error Detection

Application layer expects Infrastructure to throw `HttpRequestException` with specific status codes:
- 429 (rate limit)
- 500-504 (server errors)

Non-transient errors (401, 400) should throw different exception types or include distinguishable info.

### 5. Polly Policy Order

**Correct order**: Retry **wraps** Circuit Breaker.

**Rationale**: Circuit breaker counts failures *after* retries exhausted. Prevents false positives from transient blips.

**Implementation**:
```csharp
// Pseudo-code
AddPolicyHandler(retryPolicy)
AddPolicyHandler(circuitBreakerPolicy)
```

### 6. Snake_Case Column Naming

PostgreSQL convention: all identifiers lowercase with underscores.

**Options**:
- Manual per-column: `.HasColumnName("estimated_cost_usd")`
- Global convention: Custom `IModelCacheKeyFactory` (overkill for MVP)
- Helper extension: `ToSnakeCase()` string method

**Recommendation**: Manual for MVP (explicit, clear).

---

## Configuration Requirements

### appsettings.json
```json
{
  "ConnectionStrings": {
    "PostgreSQL": "Host=localhost;Database=llmgateway;Username=postgres;Password=postgres"
  },
  "OpenRouter": {
    "BaseUrl": "https://openrouter.ai/api/v1/",
    "ApiKey": "", // Populate in appsettings.Development.json
    "TimeoutSeconds": 30,
    "MaxRetries": 3,
    "CircuitBreakerFailureThreshold": 5,
    "CircuitBreakerCooldownSeconds": 30
  }
}
```

### User Secrets (Development)
```bash
dotnet user-secrets set "OpenRouter:ApiKey" "sk-or-v1-..."
```

---

## Testing Strategy

### Unit Tests (Mocked Dependencies)

**OpenRouterChatCompletionService**:
- Mock `HttpMessageHandler` to return fake responses
- Test metadata population
- Test retry logic (429 → retry → success)
- Test circuit breaker (5 failures → open → reject)
- Test non-transient error (401 → throw immediately)

**Repositories**:
- Use in-memory SQLite provider (`UseInMemoryDatabase` causes issues with relational features)
- Test CRUD operations
- Test value object conversion
- Test aggregations (GetTotalCost)

### Integration Tests

**Full Orchestration**:
- Real `Kernel` with real plugins
- Mocked `HttpClient` (return fake OpenRouter responses)
- In-memory SQLite for repositories
- Verify: metadata flows from completion service → orchestrator → cost tracking → response

**Database Migration**:
- Test migration applies cleanly
- Verify seed data exists after migration
- Test snake_case column names

---

## Verification Steps

**Run these to confirm US-004 completion:**

```bash
# 1. Infrastructure project builds
dotnet build src/LLMGateway.Infrastructure

# 2. All tests pass (Domain + Application + Infrastructure)
dotnet test

# 3. Migration generates correct schema
dotnet ef migrations add InitialCreate --project src/LLMGateway.Infrastructure --startup-project src/LLMGateway.Api
# Inspect generated migration for snake_case naming

# 4. Migration applies to empty database
docker run --name llmgateway-postgres -e POSTGRES_PASSWORD=postgres -p 5432:5432 -d postgres
dotnet ef database update --project src/LLMGateway.Infrastructure --startup-project src/LLMGateway.Api

# 5. Seed data exists
psql -h localhost -U postgres -d llmgateway -c "SELECT model_name, input_cost_per_1m_tokens FROM model_pricing;"
# Expected: 3 rows (glm-4.6, DeepSeek, Kimi-K2)

# 6. OpenRouter completion service can be instantiated
# Create integration test that resolves IChatCompletionService from DI
```

---

## Definition of Done

- [x] `OpenRouterChatCompletionService` implements `IChatCompletionService` with metadata population
- [x] Polly retry (3x exponential backoff) and circuit breaker (5 failures, 30s cooldown) configured
- [x] `GatewayDbContext` with entity configurations for RequestLog and ModelPricing
- [x] Value objects mapped with `OwnsOne`, all columns in snake_case
- [x] Repository implementations replace in-memory versions
- [x] `ProviderHealthChecker` with 5s timeout on health endpoint
- [x] Initial EF Core migration with seed data for 3 models
- [x] `SKServiceCollectionExtensions.AddInfrastructure()` registers all services
- [x] Solution builds without errors or warnings
- [x] Unit tests pass for completion service (mocked HTTP) and repositories (in-memory SQLite)
- [x] Integration test confirms metadata flows correctly through stack
- [x] Migration applies cleanly to empty PostgreSQL database
- [x] OpenRouter API key configured in user secrets
- [x] Code committed to GitHub with descriptive message

---

## File Structure After US-004

```
src/LLMGateway.Infrastructure/
├── ChatCompletion/
│   └── OpenRouterChatCompletionService.cs
├── Persistence/
│   ├── GatewayDbContext.cs
│   ├── Configurations/
│   │   ├── RequestLogConfiguration.cs
│   │   └── ModelPricingConfiguration.cs
│   ├── Repositories/
│   │   ├── RequestLogRepository.cs
│   │   ├── ModelPricingRepository.cs
│   │   └── ProviderHealthChecker.cs
│   └── Migrations/
│       └── {timestamp}_InitialCreate.cs
├── Resilience/
│   └── PollyPolicies.cs  (optional: policy factory)
├── Extensions/
│   └── SKServiceCollectionExtensions.cs
└── LLMGateway.Infrastructure.csproj

tests/LLMGateway.Infrastructure.Tests/
├── ChatCompletion/
│   └── OpenRouterChatCompletionServiceTests.cs
├── Repositories/
│   ├── RequestLogRepositoryTests.cs
│   ├── ModelPricingRepositoryTests.cs
│   └── ProviderHealthCheckerTests.cs
└── Integration/
    └── FullOrchestrationTests.cs
```

---

## Risks & Mitigations

### Risk 1: OpenRouter Response Format Assumption
**Problem**: Application layer expects `usage.prompt_tokens` and `usage.completion_tokens`. If OpenRouter uses different field names, metadata population fails.

**Mitigation**:
- Test with real OpenRouter API during implementation
- Add fallback: if usage object missing, log error and return empty metadata (Application layer handles gracefully)
- Document actual response structure in code comments

### Risk 2: Value Object Mapping Complexity
**Problem**: EF Core's `OwnsOne` can be tricky with nested properties and null handling.

**Mitigation**:
- Write repository tests FIRST (TDD approach)
- Use in-memory SQLite to verify mappings work
- Manually inspect generated migration SQL

### Risk 3: Circuit Breaker False Positives
**Problem**: 5 failures might be too aggressive for legitimate traffic spikes.

**Mitigation**:
- Make threshold configurable (read from appsettings)
- Log circuit state changes prominently
- Phase 2: Add metrics to tune threshold based on real data

### Risk 4: PostgreSQL Not Running
**Problem**: Tests/app fail if PostgreSQL not available.

**Mitigation**:
- Use Docker Compose for local dev (define in repo)
- Repository tests use in-memory SQLite (no Postgres required)
- Clear setup instructions in README

---

## Success Criteria Summary

✅ **Infrastructure layer is complete when:**
1. OpenRouterChatCompletionService successfully calls OpenRouter API and populates SK metadata
2. Polly policies retry transient errors and circuit breaker prevents cascading failures
3. EF Core persists RequestLog and ModelPricing with value objects correctly mapped
4. Repositories replace in-memory implementations with real database queries
5. Initial migration applies cleanly with seed data for 3 models
6. All unit and integration tests pass (40+ tests total)
7. Application layer can orchestrate full completion flow with real HTTP + database
8. Code committed to GitHub with descriptive message

---

## Time Estimate

- OpenRouterChatCompletionService: **45 minutes**
- Polly policy configuration: **15 minutes**
- GatewayDbContext + entity configs: **30 minutes**
- Repository implementations: **30 minutes**
- DI registration extension: **15 minutes**
- Initial migration + seed data: **20 minutes**
- Unit tests (completion service): **30 minutes**
- Unit tests (repositories): **20 minutes**
- Integration test: **20 minutes**
- Verification & commit: **15 minutes**
- **Total: ~4 hours**

---

## Next Steps

Once US-004 is complete:
- **US-005**: API Layer (controllers, middleware, Program.cs, Swagger)
- **US-006**: End-to-end integration testing with real OpenRouter calls
- **US-007**: Docker Compose + .NET Aspire orchestration
- **Phase 2**: Authentication, rate limiting, admin endpoints

---

## Open Questions for Implementation

1. **OpenRouter response structure**: Does OpenRouter actually return `usage.prompt_tokens` or is it `usage.input_tokens`? Test with real API.
2. **Circuit breaker scope**: Should circuit breaker be per-model or global? MVP: Global (simpler). Phase 2: Per-model.
3. **Connection pooling**: Does Npgsql need explicit pool configuration or are defaults sufficient? MVP: Use defaults.
4. **Health check endpoint**: Should `/models` call be cached (1 min TTL) to avoid rate limits? MVP: No cache (5s timeout is fast). Phase 2: Add caching.

---

## Notes for Handover to US-005

After US-004, you'll have:
- ✅ Full stack working: Domain → Application → Infrastructure
- ✅ Real OpenRouter integration with resilience
- ✅ PostgreSQL persistence with migrations
- ✅ All tests passing (60+ tests)

Missing for MVP:
- ❌ API endpoints (controllers)
- ❌ Middleware (logging, error handling)
- ❌ Startup configuration (Program.cs)
- ❌ Swagger documentation
- ❌ Health check endpoints

US-005 will wire everything together into a runnable API.