# US-005: API Layer Implementation

---

## User Story

**As a** developer  
**I want to** implement the API layer with REST endpoints, middleware, and startup configuration  
**So that** external clients can interact with the LLM Gateway via HTTP and the application is production-ready

---

## Context

Infrastructure layer (US-004) is complete with real OpenRouter integration, EF Core persistence, and Polly resilience. Now we need to expose functionality via REST API with proper error handling, logging, and API documentation.

**Goal**: Create a runnable web API that accepts chat completion requests and returns responses, with enterprise-grade middleware and observability.

---

## Acceptance Criteria

### Criterion 1: ChatCompletionController Implementation
- [ ] `ChatCompletionController` with `POST /v1/chat/completions` endpoint
- [ ] Accepts `ChatRequest` from request body
- [ ] Validates request using DataAnnotations or FluentValidation
- [ ] Calls `KernelOrchestrator.SendChatCompletionAsync()`
- [ ] Returns `ChatResponse` with 200 OK on success
- [ ] Returns 400 Bad Request for validation errors with structured error response
- [ ] Returns 500 Internal Server Error for unhandled exceptions
- [ ] Includes `[ApiController]` attribute for automatic model validation
- [ ] Uses dependency injection for orchestrator

### Criterion 2: Health Check Endpoints
- [ ] `GET /health` endpoint (basic liveness probe)
  - Returns 200 OK if service is running
  - Response: `{"status": "Healthy"}`
- [ ] `GET /health/ready` endpoint (readiness probe)
  - Checks database connectivity via EF Core
  - Checks OpenRouter availability via `IProviderHealthChecker`
  - Returns 200 OK if all dependencies healthy
  - Returns 503 Service Unavailable if any dependency unhealthy
  - Response includes dependency status details

### Criterion 3: Middleware Pipeline Configuration
- [ ] **Exception Handling Middleware** (first in pipeline):
  - Catches unhandled exceptions
  - Logs with structured logging (Serilog)
  - Returns standardized error response (ProblemDetails format)
  - Includes correlation ID in response
- [ ] **Request Logging Middleware** (Serilog.AspNetCore):
  - Logs HTTP request details (method, path, status code, duration)
  - Enriches logs with correlation ID
  - Uses structured logging format (JSON)
- [ ] **CORS Middleware** (if needed for Phase 2 web UI):
  - Configured but restrictive for MVP (localhost only)
- [ ] **Routing and endpoint mapping**

### Criterion 4: Program.cs Startup Configuration
- [ ] Calls `builder.Services.AddInfrastructure(configuration)` from US-004
- [ ] Calls `builder.Services.AddApplication()` (if not already in Infrastructure extension)
- [ ] Registers controllers with `AddControllers()`
- [ ] Configures Swagger/OpenAPI with `AddEndpointsApiExplorer()` and `AddSwaggerGen()`
- [ ] Configures Serilog from appsettings.json
- [ ] Builds middleware pipeline in correct order
- [ ] Maps controllers and health check endpoints
- [ ] Runs Swagger UI in Development environment only

### Criterion 5: Serilog Configuration
- [ ] Read configuration from `appsettings.json` ("Serilog" section)
- [ ] Console sink for Development (structured JSON)
- [ ] File sink for Production (rolling daily logs)
- [ ] Minimum level: Information (Debug for Development)
- [ ] Overrides: Microsoft.AspNetCore = Warning, Microsoft.SemanticKernel = Information
- [ ] Enrichers: FromLogContext, WithMachineName, WithThreadId
- [ ] Request logging excludes health check endpoints (reduce noise)

### Criterion 6: Error Response Standardization
- [ ] Use RFC 7807 ProblemDetails format
- [ ] Standard fields: `type`, `title`, `status`, `detail`, `instance`
- [ ] Custom extension: `correlationId` for tracing
- [ ] Validation errors include `errors` dictionary with field-level messages
- [ ] Example 400 response:
  ```json
  {
    "type": "https://tools.ietf.org/html/rfc7231#section-6.5.1",
    "title": "One or more validation errors occurred.",
    "status": 400,
    "errors": {
      "Messages": ["The Messages field is required."]
    },
    "correlationId": "abc-123"
  }
  ```

### Criterion 7: Swagger/OpenAPI Documentation
- [ ] Swagger UI available at `/swagger` in Development
- [ ] API metadata: Title "LLM Gateway API", Version "v1"
- [ ] Endpoint documentation with XML comments (optional for MVP)
- [ ] Request/response schemas auto-generated from DTOs
- [ ] Example requests in Swagger UI (via [SwaggerRequestExample])
- [ ] Disabled in Production environment

### Criterion 8: Configuration Management
- [ ] appsettings.json (base configuration)
- [ ] appsettings.Development.json (dev overrides, gitignored if contains secrets)
- [ ] appsettings.secrets.json (local secrets, gitignored)
- [ ] Environment variables override file-based config
- [ ] PostgreSQL connection string from configuration
- [ ] OpenRouter API key from secrets or environment

### Criterion 9: Integration Tests Pass
- [ ] **End-to-end test**: POST request to `/v1/chat/completions`
  - Mocked OpenRouter HTTP responses
  - In-memory SQLite database
  - Verifies full stack: Controller → Orchestrator → Plugins → Infrastructure → Response
- [ ] **Health check tests**:
  - `/health` returns 200 OK
  - `/health/ready` returns 200 when dependencies healthy
  - `/health/ready` returns 503 when database unreachable
- [ ] **Validation tests**:
  - Empty messages array returns 400
  - Invalid temperature range returns 400
  - Negative MaxTokens returns 400
- [ ] **Error handling tests**:
  - Unhandled exception returns 500 with ProblemDetails
  - Domain exception (AllProvidersFailedException) returns 503

---

## Prerequisites

**Completed:**
- ✅ US-001: Project structure
- ✅ US-002: Domain layer
- ✅ US-003/003B: Application layer with orchestration
- ✅ US-004: Infrastructure layer with OpenRouter integration

**Required Knowledge:**
- ASP.NET Core middleware pipeline order
- Dependency injection in controllers
- Serilog structured logging
- Health checks pattern
- ProblemDetails RFC 7807
- Swagger/OpenAPI basics

**External Dependencies:**
- Serilog.AspNetCore (NuGet package)
- Swashbuckle.AspNetCore (Swagger)
- Microsoft.Extensions.Diagnostics.HealthChecks (built-in)

---

## Architecture Impact

**New Layer Added**: API (Presentation)

**Dependency Flow**:
```
API Layer (Controllers, Middleware)
  → Application Layer (KernelOrchestrator)
    → Domain Layer (Interfaces, Entities)
      ← Infrastructure Layer (Implementations)
```

**Critical Rule**: Controllers are thin. Business logic stays in Application/Domain.

**Controller Responsibility**:
- Accept HTTP request
- Validate input (DataAnnotations)
- Call orchestrator
- Map to HTTP response
- Handle exceptions (via middleware)

**What Controllers Should NOT Do**:
- Business logic (routing, fallback, cost calculation)
- Direct database access
- Direct HTTP calls to providers
- Exception handling (middleware handles this)

---

## Critical Implementation Details

### 1. Middleware Pipeline Order (Critical)

**Correct Order**:
```
1. Exception Handler (catches everything below)
2. CORS (if enabled)
3. Request Logging (Serilog)
4. Routing
5. Authentication (Phase 2)
6. Authorization (Phase 2)
7. Endpoint execution (Controllers)
```

**Why Order Matters**:
- Exception handler must be first (catches errors from all subsequent middleware)
- Logging should be early (captures all requests, even failed ones)
- Authentication before authorization
- Routing before endpoint-specific middleware

### 2. Exception Handling Strategy

**Three Exception Categories**:

**Domain Exceptions** (Expected Business Errors):
- `AllProvidersFailedException` → 503 Service Unavailable
- `TokenLimitExceededException` → 400 Bad Request (user error)
- `ModelNotFoundException` → 400 Bad Request (invalid model specified)

**Validation Exceptions**:
- `ValidationException` (FluentValidation) → 400 Bad Request
- Model binding errors → 400 Bad Request (automatic via [ApiController])

**Unhandled Exceptions**:
- `Exception` (catch-all) → 500 Internal Server Error
- Log full stack trace
- Return generic error message (don't leak internal details)

### 3. Health Check Implementation

**Liveness** (`/health`):
- Simple: Is process running?
- No dependency checks
- Always returns 200 unless process crashed

**Readiness** (`/health/ready`):
- Database: Can connect to PostgreSQL?
- OpenRouter: Is provider reachable?
- Returns 503 if any dependency fails
- Kubernetes uses this for traffic routing

**Implementation Pattern**:
```csharp
// Custom health check
public class DatabaseHealthCheck : IHealthCheck
{
    public async Task<HealthCheckResult> CheckHealthAsync(...)
    {
        // Try database query
        // Return Healthy or Unhealthy
    }
}
```

### 4. Correlation ID Strategy

**Purpose**: Trace requests across logs and services.

**Implementation**:
- Generate GUID per request (middleware)
- Add to log context (Serilog enricher)
- Include in error responses (ProblemDetails.Extensions["correlationId"])
- Optional: Read from header `X-Correlation-ID` (Phase 2)

**Example Log Entry**:
```json
{
  "timestamp": "2025-10-03T12:34:56Z",
  "level": "Information",
  "message": "HTTP POST /v1/chat/completions responded 200 in 1234ms",
  "correlationId": "abc-123-def-456",
  "requestPath": "/v1/chat/completions",
  "statusCode": 200,
  "duration": 1234
}
```

### 5. Serilog Request Logging Configuration

**What to Log**:
- Request method and path
- Status code
- Response time (milliseconds)
- User agent (optional)
- Correlation ID

**What NOT to Log**:
- Request/response bodies (PII risk, performance cost)
- Authorization headers (security risk)
- Query strings with sensitive data

**Filter Out Noise**:
```csharp
.Filter.ByExcluding(logEvent => 
    logEvent.Properties.ContainsKey("RequestPath") &&
    logEvent.Properties["RequestPath"].ToString().Contains("/health"))
```

Health checks hit every 10 seconds. Don't log them.

---

## Configuration Requirements

### appsettings.json

```json
{
  "ConnectionStrings": {
    "PostgreSQL": "Host=localhost;Database=llmgateway;Username=postgres;Password=postgres"
  },
  "OpenRouter": {
    "BaseUrl": "https://openrouter.ai/api/v1/",
    "TimeoutSeconds": 30,
    "MaxRetries": 3,
    "CircuitBreakerFailureThreshold": 5,
    "CircuitBreakerCooldownSeconds": 30
  },
  "Serilog": {
    "Using": ["Serilog.Sinks.Console", "Serilog.Sinks.File"],
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft.AspNetCore": "Warning",
        "Microsoft.SemanticKernel": "Information",
        "System.Net.Http.HttpClient": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj}{NewLine}{Exception}"
        }
      },
      {
        "Name": "File",
        "Args": {
          "path": "logs/llmgateway-.log",
          "rollingInterval": "Day",
          "retainedFileCountLimit": 7
        }
      }
    ],
    "Enrich": ["FromLogContext", "WithMachineName", "WithThreadId"]
  },
  "AllowedHosts": "*"
}
```

### appsettings.Development.json

```json
{
  "Serilog": {
    "MinimumLevel": {
      "Default": "Debug"
    }
  }
}
```

### appsettings.secrets.json (gitignored)

```json
{
  "OpenRouter": {
    "ApiKey": "sk-or-v1-..."
  }
}
```

---

## Testing Strategy

### Integration Tests (WebApplicationFactory)

**Pattern**: Use `WebApplicationFactory<Program>` to test full HTTP stack.

**Setup**:
- Override services (use in-memory database)
- Mock HttpClient for OpenRouter (return fake responses)
- Configure TestServer

**Test Categories**:

**Happy Path**:
- POST valid chat request → 200 OK with ChatResponse
- Response includes model, cost, tokens

**Validation**:
- Empty messages → 400 Bad Request
- Invalid temperature (3.0) → 400 Bad Request
- Negative MaxTokens → 400 Bad Request

**Error Scenarios**:
- All providers fail → 503 Service Unavailable
- Database connection fails → 503 on /health/ready
- Unhandled exception → 500 Internal Server Error

**Health Checks**:
- `/health` always returns 200
- `/health/ready` returns 200 with healthy dependencies
- `/health/ready` returns 503 with unhealthy database

### Manual Testing (Swagger UI)

**Steps**:
1. Run application: `dotnet run --project src/LLMGateway.Api`
2. Open browser: `https://localhost:5001/swagger`
3. Execute POST /v1/chat/completions with example request
4. Verify response structure
5. Check logs in console for structured output

**Example Request** (paste in Swagger UI):
```json
{
  "messages": [
    {
      "role": "user",
      "content": "Say hello"
    }
  ]
}
```

**Expected Response**:
```json
{
  "content": "Hello! How can I assist you today?",
  "model": "z-ai/glm-4.6",
  "tokensUsed": 25,
  "estimatedCostUsd": 0.000001,
  "responseTime": "00:00:01.234"
}
```

---

## Verification Steps

**Run these to confirm US-005 completion:**

```bash
# 1. All tests pass (Domain + Application + Infrastructure + API)
dotnet test
# Expected: Passed! 80+ tests

# 2. Application runs without errors
dotnet run --project src/LLMGateway.Api
# Expected: Application started. Press Ctrl+C to shut down.
# Expected: Listening on https://localhost:5001

# 3. Health check endpoints respond
curl http://localhost:5000/health
# Expected: {"status":"Healthy"}

curl http://localhost:5000/health/ready
# Expected: {"status":"Healthy","results":{...}}

# 4. Swagger UI accessible
# Open browser: https://localhost:5001/swagger
# Expected: Swagger UI with API documentation

# 5. POST request succeeds (manual test)
curl -X POST http://localhost:5000/v1/chat/completions \
  -H "Content-Type: application/json" \
  -d '{"messages":[{"role":"user","content":"Hello"}]}'
# Expected: 200 OK with ChatResponse JSON

# 6. Logs show structured output
# Check console output during request
# Expected: [12:34:56 INF] HTTP POST /v1/chat/completions responded 200 in 1234ms

# 7. Database persists request log
# Query PostgreSQL after request
psql -h localhost -U postgres -d llmgateway \
  -c "SELECT model_used, estimated_cost_usd FROM request_logs ORDER BY timestamp DESC LIMIT 1;"
# Expected: 1 row with recent request data
```

---

## Definition of Done

- [ ] `ChatCompletionController` with POST endpoint implemented
- [ ] Health check endpoints (`/health`, `/health/ready`) working
- [ ] Exception handling middleware catches and formats errors as ProblemDetails
- [ ] Request logging middleware (Serilog) logs all HTTP requests
- [ ] Program.cs configures DI, middleware pipeline, and Swagger
- [ ] Serilog configured with console and file sinks
- [ ] ProblemDetails format for all error responses (400, 500, 503)
- [ ] Swagger UI accessible at `/swagger` in Development
- [ ] Configuration loaded from appsettings.json + secrets
- [ ] Integration tests pass (happy path, validation, errors, health checks)
- [ ] Manual testing via Swagger UI succeeds
- [ ] Application runs and accepts requests
- [ ] Logs show structured JSON output with correlation IDs
- [ ] Database persists request logs after API call
- [ ] Code committed to GitHub with descriptive message

---

## File Structure After US-005

```
src/LLMGateway.Api/
├── Controllers/
│   ├── ChatCompletionController.cs
│   └── HealthController.cs (optional, health checks can use built-in)
├── Middleware/
│   ├── ExceptionHandlingMiddleware.cs
│   └── CorrelationIdMiddleware.cs
├── HealthChecks/
│   ├── DatabaseHealthCheck.cs
│   └── OpenRouterHealthCheck.cs
├── Program.cs
├── appsettings.json
├── appsettings.Development.json
├── appsettings.secrets.json (gitignored)
└── LLMGateway.Api.csproj

tests/LLMGateway.Api.Tests/
├── IntegrationTests/
│   ├── ChatCompletionEndpointTests.cs
│   ├── HealthCheckEndpointTests.cs
│   └── ValidationTests.cs
├── TestFixtures/
│   └── WebApplicationFactory.cs (custom factory)
└── LLMGateway.Api.Tests.csproj

logs/ (created at runtime)
└── llmgateway-2025-10-03.log
```

---

## Risks & Mitigations

### Risk 1: Middleware Order Confusion
**Problem**: Wrong middleware order breaks exception handling or logging.

**Mitigation**:
- Follow documented pattern (exception handler first)
- Write integration test that triggers exception, verify ProblemDetails response
- Comment middleware order in Program.cs

### Risk 2: Secrets in Source Control
**Problem**: Accidentally commit appsettings.secrets.json or API key.

**Mitigation**:
- Add to .gitignore immediately
- Use user secrets for local dev
- Add pre-commit hook to scan for secrets (Phase 2)
- Document in README: "Never commit secrets"

### Risk 3: Health Check False Positives
**Problem**: Readiness check passes but database connection pool exhausted.

**Mitigation**:
- Use timeout on health check database query (5 seconds)
- Test health check under load
- Phase 2: Add more sophisticated checks (connection pool size, query performance)

### Risk 4: Logging Performance Impact
**Problem**: Verbose logging slows down high-traffic endpoints.

**Mitigation**:
- Use Information level (not Debug) in Production
- Filter out health check logs
- Async file sink (non-blocking writes)
- Phase 2: Add metrics instead of logging everything

### Risk 5: Swagger Exposed in Production
**Problem**: API documentation leaks implementation details.

**Mitigation**:
- Conditionally add Swagger only in Development:
  ```csharp
  if (app.Environment.IsDevelopment())
  {
      app.UseSwagger();
      app.UseSwaggerUI();
  }
  ```
- Verify Swagger returns 404 in Production mode

---

## Success Criteria Summary

**API Layer is complete when:**
1. Application runs and serves HTTP requests on configured port
2. POST /v1/chat/completions accepts requests and returns responses
3. Health check endpoints return correct status codes
4. Exceptions are caught and returned as ProblemDetails JSON
5. All HTTP requests are logged with structured format
6. Swagger UI documents API in Development environment
7. Integration tests pass (80+ total tests across all layers)
8. Manual testing via Swagger or curl succeeds
9. Database persists request logs after API calls
10. Code is committed to GitHub

---

## Time Estimate

- ChatCompletionController: 20 minutes
- Health check endpoints: 15 minutes
- Exception handling middleware: 20 minutes
- Request logging middleware: 10 minutes
- Correlation ID middleware: 10 minutes
- Program.cs configuration: 20 minutes
- Serilog setup: 15 minutes
- Swagger configuration: 10 minutes
- Integration tests (3-4 test classes): 45 minutes
- Manual testing and verification: 20 minutes
- Documentation and commit: 10 minutes
- **Total: ~3 hours**

---

## Next Steps

Once US-005 is complete:
- **US-006**: Docker Compose + .NET Aspire orchestration
- **US-007**: End-to-end testing with real OpenRouter API
- **Phase 2**: Authentication (API keys), rate limiting, admin endpoints
- **Phase 2**: Deployment (Azure App Service + Azure Database for PostgreSQL)

---

## Notes for Implementation

### Program.cs Structure

**Recommended Organization**:
```csharp
var builder = WebApplication.CreateBuilder(args);

// 1. Configuration (Serilog, appsettings)
// 2. Services registration (DI)
//    - AddInfrastructure()
//    - AddControllers()
//    - AddSwagger()
//    - AddHealthChecks()
// 3. Build app
// 4. Middleware pipeline
// 5. Map endpoints
// 6. Run
```

### Controller Design Pattern

**Keep controllers thin**:
- Accept request
- Call orchestrator
- Return response
- No try/catch (middleware handles exceptions)

**Example structure**:
```csharp
[ApiController]
[Route("v1/[controller]")]
public class ChatCompletionController : ControllerBase
{
    private readonly KernelOrchestrator _orchestrator;
    
    [HttpPost]
    public async Task<ActionResult<ChatResponse>> SendCompletion(
        [FromBody] ChatRequest request,
        CancellationToken cancellationToken)
    {
        var command = new SendChatCompletionCommand(
            request.Messages, 
            request.Model, 
            request.Temperature, 
            request.MaxTokens);
        
        var response = await _orchestrator.SendChatCompletionAsync(
            command, 
            cancellationToken);
        
        return Ok(response);
    }
}
```

### Health Check Registration

**Built-in health checks**:
```csharp
services.AddHealthChecks()
    .AddCheck<DatabaseHealthCheck>("database")
    .AddCheck<OpenRouterHealthCheck>("openrouter");
```

**Custom health check implementation**:
- Inject dependencies (DbContext, IProviderHealthChecker)
- Implement CheckHealthAsync()
- Return HealthCheckResult.Healthy() or Unhealthy()

---

## Open Questions for Implementation

1. **API versioning**: Should `/v1/` be in route or header? MVP: Route-based (simpler).

2. **CORS policy**: Allow localhost for Phase 2 web UI? MVP: No CORS (API-only).

3. **Request size limits**: Set max request body size (e.g., 1MB)? MVP: Use defaults (30MB), revisit in Phase 2.

4. **Rate limiting**: Add per-IP throttling? MVP: No (defer to Phase 2 with API key auth).

5. **Response caching**: Cache identical requests? MVP: No (defer to Phase 2).

---